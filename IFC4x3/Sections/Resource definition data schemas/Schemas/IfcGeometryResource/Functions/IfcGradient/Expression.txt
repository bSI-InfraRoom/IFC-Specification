(GradientCurve : IfcGradientCurve, Position : IfcCurveMeasureSelect) : IfcLengthMeasure;
    
  REPEAT i := 1 TO (SIZEOF(GradientCurve.Segments) - 1);
    Segment : IfcCurveSegment := GradientCurve.Segments[i];
    NextSegment : IfcCurveSegment := GradientCurve.Segments[i + 1];
    Location : IfcCartesianPoint := NextSegment\IfcCurveSegment.Placement\IfcAxis2Placement2D.Location\IfcCartesianPoint;
    SegmentPlacement : IfcAxis2Placement2D := Segment.Placement\IfcAxis2Placement2D;
    SegDistAlong : IfcParameterValue := SegmentPlacement.Location\IfcCartesianPoint.Coordinates[1];
	
    IF (Location.Coordinates[1] > Position)
      CASE TRUE OF
	  
        'IFCCIRCLE' IN TYPEOF(Segment.BaseCurve) :
          BEGIN
            RETURN SegmentPlacement.Location\IfcCartesianPoint[2] + Segment.BaseCurve.Radius * (COS(ACOS(SegmentPlacement.RefDirection[1]) / 2 - Segment.SegmentLength) - (Position - SegmentPlacement.Location\IfcCartesianPoint[1]));
          END;
		  
        'IFCCLOTHOID' IN TYPEOF(Segment.BaseCurve) :
          BEGIN			
            RETURN SegmentPlacement.Location\IfcCartesianPoint[2] + 3 ** -1 * Segment.SegmentLength ** 3 + (3 * IfcFactorial(7)) ** -1 * Segment.SegmentLength ** 7 + (5 * IfcFactorial(11)) ** -1 * Segment.SegmentLength ** 11;
          END;		
	  
          'IFCLINE' IN TYPEOF(Segment.BaseCurve) :
            BEGIN
              RETURN SegmentPlacement.Location\IfcCartesianPoint[2] + Segment.BaseCurve\IfcLine.Pnt[2] + Segment.BaseCurve\IfcLine.Dir.Orientation[2] * Segment.BaseCurve\IfcLine.Dir.Magnitude * Segment.SegmentLength;
            END;
	  
          'IFCPOLYLINE' IN TYPEOF(Segment.BaseCurve) :
            BEGIN
              RETURN SegmentPlacement.Location\IfcCartesianPoint[2] + (Segment.BaseCurve.Points[2].Coordinates[2] - Segment.BaseCurve.Points[1].Coordinates[2]) * Segment.SegmentLength;
            END;
	  
          OTHERWISE : RETURN(?);
      END_CASE;
    END_IF;
  END_REPEAT;
  RETURN(?);
